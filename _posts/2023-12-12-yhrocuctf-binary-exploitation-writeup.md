---
layout: post
title: Writeup ~ YHROCUCTF - Binary Challenge 4
subtitle: My first touch with pwntools and ROP
#gh-repo: daattali/beautiful-jekyll
#gh-badge: [star, fork, follow]
tags: [ctf, writeup, pwn, rop]
comments: true
author: M0S4YSH3LL0
---

Welcome to my first ever writeup of an binary exploitation challenge I took in scope of the YHROCUCTF.

## Prologue

I took part in the CTF event of **YHROCU** (Yorkshire and Hamold Organised Crime Unit), the [YHROCUCTF](https://yhrocuctf.com/). It was super fun, most of all the binary exploitation challenge they provided. For this reason I want to do this writeup to let you guys be part of my thinking and learning process.

## The challenge

The description of the challenge is as follows:
```
Use the "binary-exploit-4" program to gain the privileges
of ctf-flag-4, once you have them run "newgrp" 
to be able to read the flag.

If you get the flag, Joe owes you a pint (as long as you explain how you did it + save your exploit to show him).

Seriously, fair play.

....good luck
```

You can download the binary [here]().

The challenge originally is hosted on a remote host, but I don't want to expose any credentials here, so for the real flag you need to sign up to the CTF's page.

When logging into the remote server as user `ctf-user-4`, we are presented with the binary as well as `flag.txt`, which is owned by `ctf-flag-4`. We somehow need to get privileges of `ctf-flag-4` through running the binary to see the flag.

In this writeup I will cover the `local` exploitation, so make sure to download the binary as well as create a `flag.txt` file which is owned by another user, so you can not access it by `cat`ing it.


## Analyising the binary

First let's check what we have here. To see what kind of binary we are working with, we can run the `file` command.

~~~
file ./binary-exploit-4 
~~~

~~~
binary-exploit-4: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=f1b4bbf4c34b712b7ede57d6865746f8fb057424, for GNU/Linux 3.2.0, not stripped
~~~

As we can see, we are working with a `64-bit` executable which is not stripped, meaning we get some debugging symbols while analysing it with `gdb` later, sweet.

Now, we run the program to see what we are presented with.
~~~
./binary-exploit-4 
~~~

~~~
Hello there!
What is your name?
m0
Nice
~~~

We get asked what our name is and then are responded with the message "Nice"

Okay, now let's see how the program works in `gdb`. For this I use `pwndbg` which offers some neat additional functionality when analysing binaries.

~~~
pwndbg ./binary-exploit-4
~~~

Sooo, let us have a look what functions are in this binary and how the code flow is.

~~~
info functions
~~~

~~~
0x0000000000401000  _init
0x0000000000401070  puts@plt
0x0000000000401080  setresuid@plt
0x0000000000401090  geteuid@plt
0x00000000004010a0  gets@plt
0x00000000004010b0  _start
0x00000000004010e0  _dl_relocate_static_pie
0x00000000004010f0  deregister_tm_clones
0x0000000000401120  register_tm_clones
0x0000000000401160  __do_global_dtors_aux
0x0000000000401190  frame_dummy
0x0000000000401196  run
0x00000000004011da  main
0x0000000000401220  __libc_csu_init
0x0000000000401290  __libc_csu_fini
0x0000000000401298  _fini
~~~

As we can see we have two functions here, one is `main` and one is `run`. Since the entrypoint of the binary seems to be the `main` function, we want to inspect it first and have a look at the disassembly.

~~~
disassemble main
~~~
~~~
Dump of assembler code for function main:
   0x00000000004011da <+0>:	endbr64
   0x00000000004011de <+4>:	push   rbp
   0x00000000004011df <+5>:	mov    rbp,rsp
   0x00000000004011e2 <+8>:	sub    rsp,0x20
   0x00000000004011e6 <+12>:	mov    DWORD PTR [rbp-0x14],edi
   0x00000000004011e9 <+15>:	mov    QWORD PTR [rbp-0x20],rsi
   0x00000000004011ed <+19>:	call   0x401090 <geteuid@plt>
   0x00000000004011f2 <+24>:	mov    DWORD PTR [rbp-0x4],eax
   0x00000000004011f5 <+27>:	mov    edx,DWORD PTR [rbp-0x4]
   0x00000000004011f8 <+30>:	mov    ecx,DWORD PTR [rbp-0x4]
   0x00000000004011fb <+33>:	mov    eax,DWORD PTR [rbp-0x4]
   0x00000000004011fe <+36>:	mov    esi,ecx
   0x0000000000401200 <+38>:	mov    edi,eax
   0x0000000000401202 <+40>:	mov    eax,0x0
   0x0000000000401207 <+45>:	call   0x401080 <setresuid@plt>
   0x000000000040120c <+50>:	mov    eax,0x0
   0x0000000000401211 <+55>:	call   0x401196 <run>
   0x0000000000401216 <+60>:	mov    eax,0x0
   0x000000000040121b <+65>:	leave
   0x000000000040121c <+66>:	ret
~~~

For now, we only focus on the juicy parts, the `call` instructions.
First we `geteuid`, which gets the effective user id of the current user.
Then set up registers for the `setresuid` function call, which sets the real user id. Looks like a juicy function for use to make use of later in order to gain privileges of the user owning the `flag.txt`.
And last but not least, we call the `run` function, which we will inspect now.

~~~
disassemble run
~~~
~~~
Dump of assembler code for function run:
   0x0000000000401196 <+0>:	endbr64
   0x000000000040119a <+4>:	push   rbp
   0x000000000040119b <+5>:	mov    rbp,rsp
   0x000000000040119e <+8>:	sub    rsp,0x40
   0x00000000004011a2 <+12>:	lea    rdi,[rip+0xe5b]        # 0x402004
   0x00000000004011a9 <+19>:	call   0x401070 <puts@plt>
   0x00000000004011ae <+24>:	lea    rdi,[rip+0xe5c]        # 0x402011
   0x00000000004011b5 <+31>:	call   0x401070 <puts@plt>
   0x00000000004011ba <+36>:	lea    rax,[rbp-0x40]
   0x00000000004011be <+40>:	mov    rdi,rax
   0x00000000004011c1 <+43>:	mov    eax,0x0
   0x00000000004011c6 <+48>:	call   0x4010a0 <gets@plt>
   0x00000000004011cb <+53>:	lea    rdi,[rip+0xe52]        # 0x402024
   0x00000000004011d2 <+60>:	call   0x401070 <puts@plt>
   0x00000000004011d7 <+65>:	nop
   0x00000000004011d8 <+66>:	leave
   0x00000000004011d9 <+67>:	ret
~~~

Here we have 4 `call` instructions.
The first two `puts` calls will print out the greeting and the question for our name.
Before each call to `puts` we load some value into the `rdi` register, which is basically the first argument for our function according to `x86_64` calling conventions.

Let's have a look what we load into `rdi` for the first two `puts` calls:
~~~
x/s 0x402004
~~~
~~~
0x402004:	"Hello there!"
~~~

~~~
x/s 0x402011
~~~
~~~
0x402011:	"What is your name?"
~~~

The next function call is the one we are patiently waiting for: the call to the dangerous function `gets`.
This is our entry ticket into controlling the code flow of this binary. Let's find out how much input we can provide to make the binary crash with a `segvault`.

## Let's write our exploit
TODO
## Things I still don't understand lol
TODO
## Epilogue
TODO